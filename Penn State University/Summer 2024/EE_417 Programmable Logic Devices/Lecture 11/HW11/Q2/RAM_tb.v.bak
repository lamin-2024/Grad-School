				 
module RAM_tb ()

parameter	memory_hieght = 8;
parameter	data_width	  = 4;

//define the wires and registers testbench
reg									clock, reset;
reg									read_or_write;
wire	[memory_hieght -1:0]		address;
wire	[data_width		-1:0]		data_in;
wire	[data_width		-1:0]		data_out;

//probe the each address line to determine the content 
wire	[memory_hieght	-1:0]		address_0, address_1, address_2, address_3, address_4, address_5, address_6, address_7;

//instantiate the Unit under test UUT
RAM UUT (clock, reset, address, read_or_write, data_in, data_out);

//assign the probes for the address to the address to lines in the UUT
assign	address_0	= UUT.memory[0];
assign	address_1	= UUT.memory[1];
assign	address_2	= UUT.memory[2];
assign	address_3	= UUT.memory[3];
assign	address_4	= UUT.memory[4];
assign	address_5	= UUT.memory[5];
assign	address_6	= UUT.memory[6];
assign	address_7	= UUT.memory[7];

//initialize the RAM
initial
	begin
		clock 		  = 0;
		reset 		  = 0;
		read_or_write = 0;
		data_in 		  = 4'b1111;
		#100	$stop;
	end
	
//intantiate the clock cycle
initial
	begin
		forever
		#5	clock = ~clock;
	end
	
//simulate the different test scenarios
initial
	fork
		#40     reset		    = 1'b0;
		#50	  Data_in	    = 4'b1101;
		#60	  read_or_write = 1'b1;
		#80	  read_or_write = 1'b0;
		#110    Data_in       = 4'b0011;
		#120    read_or_write = 1'b0;
		#130    read_or_write = 1'b1;
		#150    Data_in       = 4'b1100;
		#160    read_or_write = 1'b1;
		#170    Data_in       = 4'b1010;
		#180    Data_in       = 4'b0110;
		#200    Data_in       = 4'b1001;
		#240    read_or_write = 1'b0;
		#260    read_or_write = 1'b1;
	join
endmodule